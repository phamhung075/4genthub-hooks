#!/bin/bash
# cclaude-wait - Delegate to agent in separate terminal AND wait for results
#
# Usage:
#   cclaude-wait <agent-name> "task_id: <task_id>"
#   cclaude-wait <agent-name> "subtask_id: <subtask_id>, task_id: <task_id>"
#
# This script:
# 1. Launches cclaude in separate terminal (visible)
# 2. Polls MCP task status until complete
# 3. Returns task results when done
#
# Example:
#   result=$(cclaude-wait coding-agent "task_id: abc-123-def")
#   result=$(cclaude-wait documentation-agent "subtask_id: xyz-456, task_id: abc-123")
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AI AGENT RULES - AUTONOMOUS WORK MODE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# When calling documentation-agent (or any agent) via cclaude-wait:
#
# 1. AUTONOMOUS OPERATION (MANDATORY)
#    - Agent must work autonomously without asking user for choices
#    - Make intelligent decisions using sequential thinking tool
#    - User should only be informed of final results, not intermediate decisions
#
# 2. SEQUENTIAL THINKING FOR DECISIONS
#    - Use mcp__sequential-thinking__sequentialthinking tool for complex choices
#    - Evaluate multiple approaches before selecting best option
#    - Document reasoning in progress_notes but execute independently
#
# 3. SUBTASK DELEGATION PATTERN
#    When delegating to documentation-agent for a subtask:
#
#    a) Create subtask first:
#       subtask = manage_subtask(
#           action="create",
#           task_id="parent-task-uuid",
#           title="Clear, specific title",
#           description="Detailed requirements",
#           progress_notes="Initial state"
#       )
#
#    b) Delegate with both IDs:
#       result=$(cclaude-wait documentation-agent \
#           "subtask_id: ${subtask.id}, task_id: ${parent_task_id}")
#
#    c) Agent receives both IDs and works autonomously:
#       - Reads subtask details from MCP
#       - Uses sequential thinking for decisions
#       - Updates progress without user interruption
#       - Completes with detailed summary
#
# 4. DECISION-MAKING GUIDELINES
#    Agent should autonomously decide on:
#    - Documentation structure and organization
#    - Which sections to include/exclude
#    - Level of technical detail needed
#    - Code examples to demonstrate concepts
#    - Cross-references and links
#
#    Use sequential thinking to evaluate:
#    - Audience needs (developers vs. end users)
#    - Completeness vs. conciseness trade-offs
#    - Clarity vs. technical accuracy balance
#
# 5. PROGRESS TRACKING
#    Agent must update MCP regularly:
#    - manage_subtask(action="update", progress_percentage=25,
#                     progress_notes="Analyzed requirements, starting outline")
#    - manage_subtask(action="update", progress_percentage=50,
#                     progress_notes="Created structure, writing content")
#    - manage_subtask(action="update", progress_percentage=75,
#                     progress_notes="Content complete, reviewing accuracy")
#
# 6. COMPLETION REQUIREMENTS
#    When work is done:
#    - Verify all requirements met
#    - Complete with comprehensive summary
#    - Document decisions made and rationale
#
#    manage_subtask(
#        action="complete",
#        subtask_id="xyz",
#        task_id="abc",
#        completion_summary="Created comprehensive API documentation with 15
#                           endpoints documented, included authentication flow
#                           examples, added troubleshooting section",
#        progress_notes="Final review complete, all sections verified",
#        insights_found=["Discovered missing error codes in spec",
#                       "Added rate limiting documentation based on code analysis"]
#    )
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if [ $# -lt 2 ]; then
    echo "Usage: cclaude-wait <agent-name> <task_id or subtask_id description> [--custom \"instructions\"]"
    echo ""
    echo "Examples:"
    echo "  # Parent task:"
    echo "  cclaude-wait coding-agent 'task_id: abc-123-def'"
    echo ""
    echo "  # Subtask:"
    echo "  cclaude-wait coding-agent 'subtask_id: xyz-456-ghi, task_id: abc-123-def'"
    echo ""
    echo "  # With custom instructions:"
    echo "  cclaude-wait coding-agent 'task_id: abc-123' --custom '6) Use strict types 7) Add tests'"
    echo ""
    echo "This command:"
    echo "  1. Opens new terminal with visible agent work"
    echo "  2. Waits for task/subtask completion"
    echo "  3. Returns results to calling session"
    exit 1
fi

AGENT_NAME="$1"
shift

# Parse optional --custom parameter
CUSTOM_INSTRUCTIONS=""
if [ $# -ge 2 ]; then
    # Check if last two arguments are --custom and its value
    LAST_ARG="${@: -1}"
    SECOND_LAST="${@: -2:1}"

    if [ "$SECOND_LAST" = "--custom" ]; then
        CUSTOM_INSTRUCTIONS="$LAST_ARG"
        # Remove last two arguments
        set -- "${@:1:$(($# - 2))}"
    fi
fi

TASK_DESC="$*"

# Extract subtask_id first (optional) - MUST extract before task_id to avoid matching "task_id" inside "subtask_id"
SUBTASK_ID=""
if [[ "$TASK_DESC" =~ subtask_id:[[:space:]]*([a-f0-9-]+) ]]; then
    SUBTASK_ID="${BASH_REMATCH[1]}"
fi

# Extract task_id (always required) - use word boundary to avoid matching inside "subtask_id"
TASK_ID=""
if [[ "$TASK_DESC" =~ (^|[^a-z])task_id:[[:space:]]*([a-f0-9-]+) ]]; then
    TASK_ID="${BASH_REMATCH[2]}"  # Match group 2 because group 1 is the boundary
else
    echo "âŒ Error: task_id not found in description"
    echo "   Format: cclaude-wait <agent-name> 'task_id: <uuid>'"
    echo "   Or:     cclaude-wait <agent-name> 'subtask_id: <uuid>, task_id: <uuid>'"
    echo ""
    echo "   You must create MCP task/subtask first:"
    echo "   1. Create task: mcp__agenthub_http__manage_task(action='create', ...)"
    echo "   2. Get task_id from response"
    echo "   3. Pass to cclaude-wait: 'task_id: <uuid>'"
    exit 1
fi

# Build autonomous work instructions as single line (CRITICAL: must be single line for cclaude parameter, avoid special chars)
BASE_AUTONOMOUS_RULES="AUTONOMOUS MODE: 1) DO NOT ask user for choices 2) USE sequential-thinking tool for decisions 3) Work independently 4) UPDATE progress at 25/50/75% with progress_notes 5) COMPLETE with detailed completion_summary, testing_notes, insights_found"

# Append custom instructions if provided
if [ -n "$CUSTOM_INSTRUCTIONS" ]; then
    FULL_AUTONOMOUS_RULES="$BASE_AUTONOMOUS_RULES $CUSTOM_INSTRUCTIONS"
else
    FULL_AUTONOMOUS_RULES="$BASE_AUTONOMOUS_RULES"
fi

AUTONOMOUS_RULES=" -- $FULL_AUTONOMOUS_RULES -- The user monitors via MCP but will NOT respond to questions - deliver complete results autonomously."

# Append autonomous rules to task description for agent
ENHANCED_TASK_DESC="${TASK_DESC}${AUTONOMOUS_RULES}"

echo "ğŸš€ Delegating to $AGENT_NAME in separate terminal..."
if [ -n "$SUBTASK_ID" ]; then
    echo "ğŸ“‹ Subtask ID: $SUBTASK_ID"
    echo "ğŸ“ Parent Task ID: $TASK_ID"
    echo "ğŸ¤– Mode: AUTONOMOUS (no user interaction required)"
else
    echo "ğŸ“ Task ID: $TASK_ID"
    echo "ğŸ¤– Mode: AUTONOMOUS (no user interaction required)"
fi
echo "ğŸ‘€ Watch progress in new terminal window"
echo "â³ Waiting for completion..."
echo ""

# Launch cclaude in background with enhanced instructions (opens terminal, returns immediately)
cclaude "$AGENT_NAME" "$ENHANCED_TASK_DESC" &
CCLAUDE_PID=$!

# Wait a moment for terminal to spawn
sleep 2

# Get directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Poll MCP task or subtask status using WebSocket-based helper
# This works from any nested project without Python path configuration
MAX_WAIT=3600    # max 1 hour timeout

# Build polling command based on whether we have a subtask
if [ -n "$SUBTASK_ID" ]; then
    TASK_RESULT=$(python3 "$SCRIPT_DIR/poll_mcp_websocket.py" "$TASK_ID" --subtask-id="$SUBTASK_ID" --timeout="$MAX_WAIT")
else
    TASK_RESULT=$(python3 "$SCRIPT_DIR/poll_mcp_websocket.py" "$TASK_ID" --timeout="$MAX_WAIT")
fi
POLL_EXIT_CODE=$?

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

if [ $POLL_EXIT_CODE -eq 0 ]; then
    # Task/subtask completed successfully - output JSON only
    echo ""
    echo "$TASK_RESULT" | python3 -m json.tool
    exit 0
else
    # Task/subtask failed or timed out
    IS_SUBTASK=$(echo "$TASK_RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('is_subtask', False))" 2>/dev/null || echo "false")

    if [ "$IS_SUBTASK" = "True" ]; then
        echo "âŒ Subtask did not complete successfully"
        CHECK_CMD="mcp__agenthub_http__manage_subtask(action='get', task_id='$TASK_ID', subtask_id='$SUBTASK_ID')"
    else
        echo "âŒ Task did not complete successfully"
        CHECK_CMD="mcp__agenthub_http__manage_task(action='get', task_id='$TASK_ID')"
    fi

    echo ""
    echo "ğŸ“Š Status:"
    echo "$TASK_RESULT" | python3 -m json.tool
    echo ""
    echo "ğŸ’¡ Check the terminal window for agent output"
    echo "ğŸ’¡ Task may still be running - use: $CHECK_CMD"
    exit 1
fi
