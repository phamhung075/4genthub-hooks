#!/usr/bin/env bash
###############################################################################
# cclaude-wait-parallel - Parallel Subtask Delegation with Live Progress
#
# Purpose:
#   Delegates multiple subtasks to agents in parallel with live progress updates,
#   mimicking the Task tool's parallel execution capabilities.
#
# Usage:
#   cclaude-wait-parallel <agent_name> <task_id> <subtask_id1> <subtask_id2> <subtask_id3> [...]
#
# Example:
#   cclaude-wait-parallel documentation-agent abc-123 sub1-uuid sub2-uuid sub3-uuid
#
# Features:
#   - Launches multiple cclaude sessions in parallel (separate terminals)
#   - Single WebSocket connection monitors all subtasks simultaneously
#   - Displays aggregated live progress in orchestrator session
#   - Waits for all completions before continuing
#   - Returns combined JSON results
#
# Architecture:
#   1. Launch all cclaude commands in parallel (background processes)
#   2. Start WebSocket multiplexer that subscribes to all subtask events
#   3. Display live progress updates as they arrive
#   4. Wait for all to complete
#   5. Return aggregated results
###############################################################################

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MAX_WAIT="${CCLAUDE_WAIT_TIMEOUT:-3600}"  # Default 1 hour

# Parse arguments
if [ $# -lt 3 ]; then
    echo "âŒ ERROR: Insufficient arguments" >&2
    echo "" >&2
    echo "Usage: cclaude-wait-parallel <agent_name> <task_id> <subtask_id1> [subtask_id2] [...]" >&2
    echo "" >&2
    echo "Example:" >&2
    echo "  cclaude-wait-parallel documentation-agent abc-123 sub1-uuid sub2-uuid sub3-uuid" >&2
    exit 1
fi

AGENT_NAME="$1"
TASK_ID="$2"
shift 2  # Remove agent and task_id, leaving only subtask IDs

SUBTASK_IDS=("$@")
SUBTASK_COUNT=${#SUBTASK_IDS[@]}

echo "ðŸš€ Parallel Subtask Delegation" >&2
echo "ðŸ“‹ Task ID: $TASK_ID" >&2
echo "ðŸ¤– Agent: $AGENT_NAME" >&2
echo "ðŸ“ Subtasks: $SUBTASK_COUNT" >&2
echo "" >&2

# Launch all cclaude commands in parallel
declare -a CCLAUDE_PIDS=()
declare -a TEMP_FILES=()

for i in "${!SUBTASK_IDS[@]}"; do
    SUBTASK_ID="${SUBTASK_IDS[$i]}"
    TEMP_FILE=$(mktemp /tmp/cclaude_result_XXXXXX.json)
    TEMP_FILES+=("$TEMP_FILE")

    # Build enhanced task description for autonomous mode
    ENHANCED_TASK_DESC="subtask_id: $SUBTASK_ID, task_id: $TASK_ID -- AUTONOMOUS MODE: 1) DO NOT ask user for choices 2) USE sequential-thinking tool for decisions 3) Work independently 4) UPDATE progress at 25/50/75% with progress_notes 5) COMPLETE with detailed completion_summary, testing_notes, insights_found -- The user monitors via MCP but will NOT respond to questions - deliver complete results autonomously."

    echo "  [$((i+1))/$SUBTASK_COUNT] Launching subtask $SUBTASK_ID..." >&2

    # Launch cclaude in background, redirecting to temp file
    cclaude "$AGENT_NAME" "$ENHANCED_TASK_DESC" > "$TEMP_FILE" 2>&1 &
    CCLAUDE_PIDS+=($!)
done

echo "" >&2
echo "âœ… All cclaude sessions launched" >&2
echo "ðŸ‘€ Starting live progress monitoring..." >&2
echo "" >&2

# Now launch the WebSocket multiplexer to monitor all subtasks
python3 "$SCRIPT_DIR/poll_mcp_websocket_parallel.py" \
    "$TASK_ID" \
    --subtask-ids="${SUBTASK_IDS[*]}" \
    --timeout="$MAX_WAIT"

# Store result from WebSocket multiplexer
MULTIPLEXER_EXIT_CODE=$?

echo "" >&2
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
echo "" >&2

# Wait for all cclaude processes to finish
for i in "${!CCLAUDE_PIDS[@]}"; do
    PID="${CCLAUDE_PIDS[$i]}"
    wait "$PID" 2>/dev/null || true
done

# Check if multiplexer succeeded
if [ $MULTIPLEXER_EXIT_CODE -ne 0 ]; then
    echo "âŒ WebSocket monitoring failed with exit code: $MULTIPLEXER_EXIT_CODE" >&2

    # Output partial results if available
    echo "{"
    echo "  \"success\": false,"
    echo "  \"error\": \"WebSocket monitoring failed\","
    echo "  \"exit_code\": $MULTIPLEXER_EXIT_CODE"
    echo "}"

    # Cleanup temp files
    for TEMP_FILE in "${TEMP_FILES[@]}"; do
        rm -f "$TEMP_FILE"
    done

    exit 1
fi

# Cleanup temp files
for TEMP_FILE in "${TEMP_FILES[@]}"; do
    rm -f "$TEMP_FILE"
done

echo "âœ… All subtasks completed successfully!" >&2
exit 0
